'use client'

import moment from "moment";
import Link from "next/link";
import { useRef, useState } from "react";
import { syllable } from "syllable";
import { FaCopy, FaEdit } from "react-icons/fa";
import useAlert from "@/app/_hooks/alert";
import useHaikus from "@/app/_hooks/haikus";
import { Haiku } from "@/types/Haiku";
import { USAGE_LIMIT } from "@/types/Usage";
import { User } from "@/types/User";
import { capitalize, upperCaseFirstLetter } from "@/utils/format";
import trackEvent from "@/utils/trackEvent";
import { GenerateIcon } from "./Nav";
import PopOnClick from "./PopOnClick";
import { StyledLayers } from "./StyledLayers";

export default function HaikuPoem({
  user,
  mode,
  haiku,
  popPoem,
  styles,
  altStyles,
  regenerate,
  refresh,
}: {
  user: User,
  mode: string,
  haiku: Haiku,
  popPoem?: boolean,
  styles: any[],
  altStyles?: any[],
  regenerate?: any,
  refresh?: any
}) {
  // console.log('>> app._components.HaikuPoem.render()', { mode, haikuId: haiku?.id, status: haiku.status, popPoem, haiku });
  const isHaikudleMode = mode == "haikudle";
  const isShowcaseMode = mode == "showcase";
  const maxHaikuTheme = 18;
  const dateCode = moment().format("YYYYMMDD");

  // can't create refs in a loop: hopefully 10 will be enough for most usecase
  const inputRefs: any[] = [useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef()]
  const [updatedLines, setUpdatedLines] = useState<string[]>([]);
  const [editMode, setEditMode] = useState(false);
  const [saving, setSaving] = useState(false);

  const [alert] = useAlert((state: any) => [state.plain]);
  const [saveHaiku] = useHaikus((state: any) => [state.save]);

  // console.log('>> app._components.HaikuPage.HaikuPoem.render()', { poem, pop });

  const haikuTitleAndAuthorTag = [
    `"${capitalize(haiku.theme)}", `,
    `generated by ${isHaikudleMode || isShowcaseMode ? "haikudle.art" : "haiku.desmat.ca"} (${moment(haiku.createdAt).format("YYYY")})`
  ];

  const handleClickHaiku = (e: any) => {
    if (mode == "showcase") {
      return refresh && refresh(e);
    }

    const haikuToCopy = haiku.poem
      .map((line: string, i: number) => upperCaseFirstLetter(updatedLines[i] || line))
      .join("\n")
      + `\n—${haikuTitleAndAuthorTag.join("")}\n`;

    // console.log('>> app._components.HaikuPage.handleClickHaiku()', { haikuToCopy });
    navigator.clipboard.writeText(haikuToCopy);

    alert(`Haiku poem copied to clipboard`, { closeDelay: 750 });

    trackEvent("haiku-copied", {
      userId: user.id,
      id: haiku.id,
    });
  }

  const startEdit = (inputIndex?: number) => {
    setEditMode(true);
    // allow a bit of time for re-draw
    const ref = inputRefs[inputIndex || 0];
    setTimeout(() => {
      ref?.current && ref.current.focus();
      ref?.current && ref.current.select();
    }, 10);
  }

  const cancelEdit = () => {
    setUpdatedLines(haiku.poem.map((line: string) => line));
    setEditMode(false);
  }

  const finishEdit = async () => {
    console.log('>> app._components.HaikuPoem.finishEdit()', { haiku, poem: haiku.poem, updatedLines });
    setEditMode(false);

    // TODO UNCPLIPPLE
    if (updatedLines.length == 0 || haiku.poem.join("/") == updatedLines.join("/")) {
      // no updates to save
      return;
    }

    setSaving(true);

    const syllables = haiku.poem
      .map((line: string, i: number) => (updatedLines[i] || line || "").split(/\s/)
        .map((word: string) => syllable(word))
        .reduce((a: number, v: number) => a + v, 0))
    console.log('>> app._components.HaikuPoem.finishEdit()', { syllables });

    const updatedOpen = haiku.poem
      .map((line: string, i: number) => {
        if (updatedLines[i] == "") return "...";
        if (updatedLines[i] && (updatedLines[i].includes("...") || updatedLines[i].includes("…"))) return updatedLines[i];
        // if ((i == 0 || i == 2) && syllables[i] <= 3) return `${updatedLines[i] || line} ...`;
        // if (i == 1 && syllables[i] <= 5) return `${updatedLines[i] || line} ...`;
        if ((i == 0 || i == 2) && syllables[i] <= 3) return `... ${updatedLines[i] || line} ...`;
        if (i == 1 && syllables[i] <= 5) return `... ${updatedLines[i] || line} ...`;
        return updatedLines[i] || line;
      });

    try {
      const saved = await saveHaiku(user, {
        ...haiku,
        originalPoem: haiku.poem,
        poem: updatedOpen,
      });

      // TODO check error
      console.log('>> app._components.HaikuPoem.finishEdit()', { saved });
      haiku.poem = saved.poem;
      setUpdatedLines(saved.poem.map((line: string) => line));
      setSaving(false);
    } catch (error: any) {
      console.log('>> app._components.HaikuPoem.finishEdit()', { error });
      setUpdatedLines(haiku.poem.map((line: string) => line));
      setSaving(false);
    }
  }

  const handlePoemLineKeyDown = (e: any, lineNumber: number) => {
    // console.log({ e, key: e.key });
    if (e.key == "Escape") {
      cancelEdit();
    } else if (e.key == "Enter") {
      if (lineNumber == haiku.poem.length - 1) {
        finishEdit();
      } else {
        // next line
        inputRefs[lineNumber + 1].current.focus();
        inputRefs[lineNumber + 1].current.select();
      }
    } else if (e.key == "Tab") {
      if (lineNumber == 0 && e.shiftKey || lineNumber == haiku.poem.length - 1 && !e.shiftKey) {
        finishEdit();
      }
    }
  };

  const handleInputChange = (e: any, lineNumber: number) => {
    // console.log(e.target.value);
    updatedLines[lineNumber] = upperCaseFirstLetter(e.target.value);
    setUpdatedLines([...updatedLines]);
  };

  return (
    <div className="relative">
      <div
        className={`_bg-pink-200 fixed top-0 left-0 w-[100vw] h-[100vh]${saving ? " opacity-50" : ""}`}
        onClick={() => editMode && finishEdit()}
      />

      <PopOnClick color={haiku.bgColor} force={popPoem} disabled={!isShowcaseMode}>
        <div className={saving ? "animate-pulse" : ""}>
          <div
            className="_bg-purple-200 flex flex-col transition-all"
            onClick={(e: any) => {
              e.preventDefault();
              // if (!editMode) {
              //   handleClickHaiku(e);
              // }
              isShowcaseMode && handleClickHaiku(e)
            }}
            title={isShowcaseMode ? "Refresh" : "Click to edit"}
            style={{
              cursor: isShowcaseMode ? "pointer" : ""
            }}
          >
            {haiku.poem.map((line: string, i: number) => (
              <StyledLayers key={i} styles={styles}>
                <div
                  className="relative m-[0rem] transition-all"
                  onKeyDown={(e: any) => handlePoemLineKeyDown(e, i)}
                  onClick={(e: any) => !editMode && startEdit(i)}
                >
                  {/* used to set the width */}
                  <div
                    className="_bg-pink-200 px-[0.5rem] h-[2.2rem] sm:h-[2.6rem] md:h-[3.2rem]"
                    style={{
                      visibility: editMode ? "hidden" : "visible"
                    }}
                  >
                    {/* keep at minimum original width to avoid wierd alignment issues */}
                    <div className="_bg-orange-200 h-0 invisible">
                      {line}
                    </div>
                    {/* show this when not editing */}
                    <div className="_bg-yellow-200">
                      {typeof (updatedLines[i]) == "string" ? updatedLines[i] : line}
                    </div>
                  </div>
                  {/* show input fields in edit mode */}
                  <input
                    ref={inputRefs[i]}
                    className="w-full absolute top-0 left-[-0.01rem] px-[0.5rem]"
                    style={{
                      background: "none",
                      visibility: editMode ? "visible" : "hidden"
                    }}
                    onChange={(e: any) => handleInputChange(e, i)}
                    defaultValue={line}
                    value={updatedLines[i]}
                  >
                  </input>
                </div>
              </StyledLayers>
            ))}
          </div>
          <div
            className="relative md:text-[14pt] sm:text-[10pt] text-[8pt] md:mt-[-0.3rem] sm:mt-[-0.2rem] mt-[-0.1rem] pl-[0.7rem]"
            style={{
              // background: "pink",
              height: mode == "haikudle"
                ? ""
                : haiku.theme?.length > maxHaikuTheme
                  ? "2.6rem"
                  : "1.3rem"
            }}
          >
            <div className="absolute w-max flex flex-row">
              <div
                className="transition-all"
                onClick={(e: any) => isShowcaseMode && handleClickHaiku(e)}
                title={isShowcaseMode ? "Refresh" : ""}
                style={{
                  cursor: isShowcaseMode ? "pointer" : ""
                }}
              >
                <StyledLayers styles={styles}>
                  <span
                    dangerouslySetInnerHTML={{ __html: `—${haikuTitleAndAuthorTag.join(haiku.theme?.length > maxHaikuTheme ? "<br/>&nbsp;" : "")}` }}
                  >
                  </span>
                </StyledLayers>
              </div>

              {regenerate && !isShowcaseMode && (user?.isAdmin || haiku.createdBy == user?.id) &&
                <div
                  className="flex flex-row gap-2 mt-auto md:pt-[0rem] sm:pt-[0.0rem] md:pb-[0.4rem] sm:pb-[0.3rem] pb-[0.2rem] md:pl-[0.9rem] sm:pl-[0.7rem] pl-[0.5rem]"
                >
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Copy to clipboard"
                    onClick={(e: any) => {
                      e.preventDefault();
                      handleClickHaiku(e);
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaCopy className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Edit this haiku"
                    onClick={(e: any) => {
                      e.preventDefault();
                      startEdit();
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaEdit className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  {!user?.isAdmin && (user.usage[dateCode]?.haikusRegenerated || 0) >= USAGE_LIMIT.DAILY_REGENERATE_HAIKU &&
                    <span
                      className="opacity-40"
                      title="Exceeded daily limit: try again later"
                    >
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                      </StyledLayers>
                    </span>
                  }
                  {(user?.isAdmin || (user.usage[dateCode]?.haikusRegenerated || 0) < USAGE_LIMIT.DAILY_REGENERATE_HAIKU) &&
                    <span title="Regenerate this haiku with the same theme">
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon
                          onClick={() => regenerate && regenerate()}
                          sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6"
                        />
                      </StyledLayers>
                    </span>
                  }
                </div>
              }
            </div>
          </div>
        </div>
      </PopOnClick>
    </div>
  )
}
