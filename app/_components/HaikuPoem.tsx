'use client'

import moment from "moment";
import Link from "next/link";
import { useEffect, useRef, useState } from "react";
import { syllable } from "syllable";
import { FaCopy, FaEdit } from "react-icons/fa";
import useAlert from "@/app/_hooks/alert";
import useHaikus from "@/app/_hooks/haikus";
import { Haiku } from "@/types/Haiku";
import { USAGE_LIMIT } from "@/types/Usage";
import { User } from "@/types/User";
import { capitalize, upperCaseFirstLetter } from "@/utils/format";
import trackEvent from "@/utils/trackEvent";
import { GenerateIcon } from "./Nav";
import PopOnClick from "./PopOnClick";
import { StyledLayers } from "./StyledLayers";

// function PoemLineInput({
//   line,
//   haiku,
//   // ref,
//   visible,
//   onChange,
// }: {
//   line: string,
//   haiku: Haiku,
//   // ref: any,
//   visible: boolean,
//   onChange: any
// }) {
//   const [updatedLine, setUpdatedLine] = useState(line);
//   const ref = useRef();
//   console.log('>> app._components.PoemLineInput.render()', { visible, line, updatedLine, ref });

//   useEffect(() => {
//     console.log('>> app._components.PoemLineInput.useEffect()', { visible, line, updatedLine, ref });

//     ref?.current && ref.current.focus();
//     ref?.current && ref.current.setSelectionRange(0, 0);
//   });

//   return (
//     <>
//       {/* https://stackoverflow.com/questions/28269669/css-pseudo-elements-in-react */}
//       <style
//         dangerouslySetInnerHTML={{
//           __html: `
//             .poem-input {
//               background: none;
//             }
//             .poem-input:focus {
//               outline: 2px solid ${haiku?.bgColor || ""}88;
//               background-color: ${haiku?.bgColor || "white"}88;
//               border-radius: 5px;
//               caret-color: ${haiku?.color || "black"};
//             }
//             ::selection { 
//               background: ${haiku.color || "black"}66 
//             }`
//         }}
//       >
//       </style>
//       <input
//         ref={ref}
//         className="poem-input w-full absolute top-0 left-[-0.01rem] px-[0.5rem]"
//         style={{
//           visibility: visible ? "visible" : "hidden",
//         }}
//         onChange={(e: any) => {
//           // e.preventDefault();
//           setUpdatedLine(e.target.value);
//           onChange(e);
//         }}
//         // defaultValue={line}
//         value={updatedLine}
//       >
//       </input>
//     </>
//   )
// }

export default function HaikuPoem({
  user,
  mode,
  haiku,
  popPoem,
  styles,
  altStyles,
  regenerate,
  refresh,
}: {
  user: User,
  mode: string,
  haiku: Haiku,
  popPoem?: boolean,
  styles: any[],
  altStyles?: any[],
  regenerate?: any,
  refresh?: any
}) {
  // console.log('>> app._components.HaikuPoem.render()', { mode, haikuId: haiku?.id, status: haiku.status, popPoem, haiku });
  const isHaikudleMode = mode == "haikudle";
  const isShowcaseMode = mode == "showcase";
  const maxHaikuTheme = 18;
  const dateCode = moment().format("YYYYMMDD");

  // can't create refs in a loop: hopefully 10 will be enough for most usecase
  const inputRefs: any[] = [useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef(), useRef()]
  // let [updatedLines, setUpdatedLines] = useState<string[]>(haiku && haiku.poem.map((line: string) => line) || []);
  let [updatedLines, setUpdatedLines] = useState<string[]>([]);
  const [editMode, setEditMode] = useState(false);
  const [saving, setSaving] = useState(false);
  // const [editingLineNumber, setEditingLineNumber] = useState(Array.from(new Array(haiku?.poem?.length)));

  const [alert] = useAlert((state: any) => [state.plain]);
  const [saveHaiku] = useHaikus((state: any) => [state.save]);

  // console.log('>> app._components.HaikuPage.HaikuPoem.render()', { poem, pop });
  // console.log('>> app._components.HaikuPage.HaikuPoem.render()', { inputRefs });
  const haikuTitleAndAuthorTag = [
    `"${capitalize(haiku.theme)}", `,
    `generated by ${isHaikudleMode || isShowcaseMode ? "haikudle.art" : "haiku.desmat.ca"} (${moment(haiku.createdAt).format("YYYY")})`
  ];

  const handleClickHaiku = (e: any) => {
    if (mode == "showcase") {
      return refresh && refresh(e);
    }

    const haikuToCopy = haiku.poem
      .map((line: string, i: number) => upperCaseFirstLetter(updatedLines[i] || line))
      .join("\n")
      + `\n—${haikuTitleAndAuthorTag.join("")}\n`;

    // console.log('>> app._components.HaikuPage.handleClickHaiku()', { haikuToCopy });
    navigator.clipboard.writeText(haikuToCopy);

    alert(`Haiku poem copied to clipboard`, { closeDelay: 750 });

    trackEvent("haiku-copied", {
      userId: user.id,
      id: haiku.id,
    });
  }

  const startEdit = (inputIndex: number, expandSelection?: boolean) => {
    console.log('>> app._components.HaikuPoem.startEdit()', { inputIndex, expandSelection });
    setEditMode(true);
    // editingLineNumber[inputIndex] = true;
    // setEditingLineNumber(editingLineNumber);
    updatedLines[inputIndex] = updatedLines[inputIndex] || haiku.poem[inputIndex];
    // const updated = [...updatedLines]
    setUpdatedLines([...updatedLines]);
    // updatedLines = updated;

    // allow a bit of time for re-draw
    setTimeout(() => {
      const ref = inputRefs[inputIndex || 0];
      console.log('>> app._components.HaikuPoem.startEdit()', { currentRef: ref?.current });
      ref?.current && ref.current.focus();
      if (expandSelection) {
        ref?.current && ref.current.select();
      } else {
        ref?.current && ref.current.setSelectionRange(0, 0);
      }
    }, 10);
  }

  const cancelEdit = () => {
    // setUpdatedLines(haiku.poem.map((line: string) => line));
    setUpdatedLines([]);
    setEditMode(false);
  }

  const finishEdit = async () => {
    console.log('>> app._components.HaikuPoem.finishEdit()', { haiku, poem: haiku.poem, updatedLines });
    setEditMode(false);

    if (updatedLines.length == 0 || haiku.poem.join("/") == updatedLines.join("/")) {
      // no updates to save
      return;
    }

    setSaving(true);

    const syllables = haiku.poem
      .map((line: string, i: number) => (updatedLines[i] || line || "").split(/\s/)
        .map((word: string) => syllable(word))
        .reduce((a: number, v: number) => a + v, 0))
    console.log('>> app._components.HaikuPoem.finishEdit()', { syllables });

    const updatedOpen = haiku.poem
      .map((line: string, i: number) => {
        if (updatedLines[i] == "") return "...";
        if (updatedLines[i] && (updatedLines[i].includes("...") || updatedLines[i].includes("…"))) return updatedLines[i];
        // if ((i == 0 || i == 2) && syllables[i] <= 3) return `${updatedLines[i] || line} ...`;
        // if (i == 1 && syllables[i] <= 5) return `${updatedLines[i] || line} ...`;
        if ((i == 0 || i == 2) && syllables[i] <= 3) return `... ${updatedLines[i] || line} ...`;
        if (i == 1 && syllables[i] <= 5) return `... ${updatedLines[i] || line} ...`;
        return updatedLines[i] || line;
      });

    try {
      const saved = await saveHaiku(user, {
        ...haiku,
        originalPoem: haiku.poem,
        poem: updatedOpen,
      });

      // TODO check error
      console.log('>> app._components.HaikuPoem.finishEdit()', { saved });
      haiku.poem = saved.poem;
      setUpdatedLines(saved.poem.map((line: string) => line));
      setSaving(false);
    } catch (error: any) {
      console.log('>> app._components.HaikuPoem.finishEdit()', { error });
      setUpdatedLines(haiku.poem.map((line: string) => line));
      setSaving(false);
    }
  }

  const handlePoemLineKeyDown = (e: any, lineNumber: number) => {
    console.log({ e, key: e.key, lineNumber });
    if (e.key == "Escape") {
      cancelEdit();
    } else if (e.key == "Enter") {
      if (lineNumber == haiku.poem.length - 1) {
        finishEdit();
      } else {
        // next line
        inputRefs[lineNumber + 1].current.focus();
        inputRefs[lineNumber + 1].current.select();
      }
    } else if (e.key == "Tab") {
      if (lineNumber == 0 && e.shiftKey || lineNumber == haiku.poem.length - 1 && !e.shiftKey) {
        finishEdit();
      } else {
        startEdit(lineNumber + (e.shiftKey ? -1 : 1), true);
      }
    } else if (e.key == "ArrowUp" && lineNumber > 0) {
      startEdit(lineNumber - 1, true);
    } else if (e.key == "ArrowDown" && lineNumber < haiku.poem.length - 1) {
      startEdit(lineNumber + 1, true);
      // } else if (["ArrowUp", "ArrowDown"].includes(e.key)) {
      //   // e.preventDefault();
    }
  };

  const handleInputChange = (e: any, lineNumber: number) => {
    // console.log(e.target.value);
    const updated = [...updatedLines];
    updated[lineNumber] = upperCaseFirstLetter(e.target.value);
    // setTimeout(() => {
    updatedLines = updated;
    setUpdatedLines(updated);
    // }, 1);
  };

  return (
    <div className="relative">
      <div
        className={`_bg-pink-200 fixed top-0 left-0 w-[100vw] h-[100vh]${saving ? " opacity-50" : ""}`}
        onClick={() => editMode && finishEdit()}
      />

      <PopOnClick color={haiku.bgColor} force={popPoem} disabled={!isShowcaseMode}>
        <div className={saving ? "animate-pulse" : ""}>
          <div
            className="_bg-purple-200 flex flex-col transition-all"
            onClick={(e: any) => {
              e.preventDefault();
              // if (!editMode) {
              //   handleClickHaiku(e);
              // }
              isShowcaseMode && handleClickHaiku(e)
            }}
            title={isShowcaseMode ? "Refresh" : "Click to edit"}
            style={{
              cursor: isShowcaseMode ? "pointer" : ""
            }}
          >
            {haiku.poem.map((line: string, i: number) => (
              <StyledLayers key={i} styles={styles}>
                <div
                  className="relative m-[0rem] transition-all"
                  onKeyDown={(e: any) => handlePoemLineKeyDown(e, i)}
                  onMouseDown={(e: any) => !editMode && startEdit(i)}
                >
                  {/* used to set the width */}
                  <div
                    className="_bg-pink-200 px-[0.5rem] h-[2.2rem] sm:h-[2.6rem] md:h-[3.2rem]"
                    style={{
                      visibility: editMode ? "hidden" : "visible"
                    }}
                  >
                    {/* keep at minimum original width to avoid wierd alignment issues */}
                    <div className="_bg-orange-200 h-0 invisible">
                      {line}
                    </div>
                    {/* show this when not editing */}
                    <div className="_bg-yellow-200">
                      {typeof (updatedLines[i]) == "string" ? updatedLines[i] : line}
                    </div>
                  </div>
                  {/* show input fields in edit mode */}
                  {
                    // editMode && editingLineNumber[i] && 
                    //   <PoemLineInput
                    //     line={updatedLines[i] /* line */}
                    //     haiku={haiku}
                    //     // ref={inputRefs[i]}
                    //     visible={editMode}
                    //     onChange={(e: any) => handleInputChange(e, i)}
                    //   />
                  }
                  {/* https://stackoverflow.com/questions/28269669/css-pseudo-elements-in-react */}
                  <style
                    dangerouslySetInnerHTML={{
                      __html: `
                        .poem-input {
                          background: none;
                        }
                        .poem-input:focus {
                          outline: 2px solid ${haiku?.bgColor}88;
                          background-color: ${haiku?.bgColor}88;
                          border-radius: 5px;
                          caret-color: ${haiku?.color};
                        }
                        ::selection { 
                          background: ${haiku.color}66 
                        }`
                    }}
                  >
                  </style>
                  <input
                    ref={inputRefs[i]}
                    className="w-full absolute top-0 left-[-0.01rem] px-[0.5rem]"
                    style={{
                      background: "none",
                      visibility: editMode ? "visible" : "hidden",
                    }}
                    onChange={(e: any) => handleInputChange(e, i)}
                    // defaultValue={line}
                    value={typeof (updatedLines[i]) == "string" ? updatedLines[i] : line}
                  >
                  </input>
                </div>
              </StyledLayers>
            ))}
          </div>
          <div
            className="relative md:text-[14pt] sm:text-[10pt] text-[8pt] md:mt-[-0.3rem] sm:mt-[-0.2rem] mt-[-0.1rem] pl-[0.7rem]"
            style={{
              // background: "pink",
              height: mode == "haikudle"
                ? ""
                : haiku.theme?.length > maxHaikuTheme
                  ? "2.6rem"
                  : "1.3rem"
            }}
          >
            <div className="absolute w-max flex flex-row">
              <div
                className="transition-all"
                onClick={(e: any) => isShowcaseMode && handleClickHaiku(e)}
                title={isShowcaseMode ? "Refresh" : ""}
                style={{
                  cursor: isShowcaseMode ? "pointer" : ""
                }}
              >
                <StyledLayers styles={styles}>
                  <span
                    dangerouslySetInnerHTML={{ __html: `—${haikuTitleAndAuthorTag.join(haiku.theme?.length > maxHaikuTheme ? "<br/>&nbsp;" : "")}` }}
                  >
                  </span>
                </StyledLayers>
              </div>

              {regenerate && !isShowcaseMode && (user?.isAdmin || haiku.createdBy == user?.id) &&
                <div
                  className="flex flex-row gap-2 mt-auto md:pt-[0rem] sm:pt-[0.0rem] md:pb-[0.4rem] sm:pb-[0.3rem] pb-[0.2rem] md:pl-[0.9rem] sm:pl-[0.7rem] pl-[0.5rem]"
                >
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Copy to clipboard"
                    onClick={(e: any) => {
                      e.preventDefault();
                      handleClickHaiku(e);
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaCopy className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Edit this haiku"
                    onClick={(e: any) => {
                      e.preventDefault();
                      startEdit(0, true);
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaEdit className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  {!user?.isAdmin && (user.usage[dateCode]?.haikusRegenerated || 0) >= USAGE_LIMIT.DAILY_REGENERATE_HAIKU &&
                    <span
                      className="opacity-40"
                      title="Exceeded daily limit: try again later"
                    >
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                      </StyledLayers>
                    </span>
                  }
                  {(user?.isAdmin || (user.usage[dateCode]?.haikusRegenerated || 0) < USAGE_LIMIT.DAILY_REGENERATE_HAIKU) &&
                    <span title="Regenerate this haiku with the same theme">
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon
                          onClick={() => regenerate && regenerate()}
                          sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6"
                        />
                      </StyledLayers>
                    </span>
                  }
                </div>
              }
            </div>
          </div>
        </div>
      </PopOnClick>
    </div>
  )
}
