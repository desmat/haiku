'use client'

import moment from "moment";
import Link from "next/link";
import { useEffect, useRef, useState } from "react";
import { syllable } from "syllable";
import { FaCopy, FaEdit } from "react-icons/fa";
import useAlert from "@/app/_hooks/alert";
import useHaikus from "@/app/_hooks/haikus";
import { Haiku } from "@/types/Haiku";
import { USAGE_LIMIT } from "@/types/Usage";
import { User } from "@/types/User";
import { capitalize, upperCaseFirstLetter } from "@/utils/format";
import trackEvent from "@/utils/trackEvent";
import { GenerateIcon } from "./Nav";
import PopOnClick from "./PopOnClick";
import { StyledLayers } from "./StyledLayers";

/**
 * Extra efforts at the UX with a controlled input.
 * Making sure that the following is smooth with respect to the input control:
 * - programmatically set focus
 * - programmatically select content
 * - correctly handle Enter, Esc, Tab and arrow keys
 * - smooth (apparent) transition between view and edit on mouse down
 * - normal cursor behaviour in all circumstances
 * Assumption: id will stay contant for each input,
 *  activeId will either be undefined (not editing) or a number
 *  corresponding to the input with matching id
 */
export function ControlledInput({
  id,
  activeId,
  value,
  visible,
  select,
  onChange,
}: {
  id: number,
  activeId?: number,
  value?: string,
  visible: boolean,
  select?: boolean,
  onChange: any,
}) {
  const [localValue, setLocalValue] = useState<string>(upperCaseFirstLetter(value || ""));
  const [active, setActive] = useState(false);
  const ref = useRef();
  // console.log('>> app._components.PoemLineInput.render()', { id, activeId, visible, select, value, updatedLine: localValue });

  useEffect(() => {
    // console.log('>> app._components.PoemLineInput.useEffect()', { id, activeId, visible, ref, value, updatedLine: localValue });

    if (typeof (activeId) == "number") {
      if (activeId == id && typeof (value) == "string" && !active) {
        // console.log('>> app._components.PoemLineInput.useEffect() setFocus', { id, activeId, visible, select, value, updatedLine: localValue });
        setActive(true);

        // @ts-ignore
        ref?.current && ref.current.focus();

        if (select) {
          // @ts-ignore
          ref?.current && ref.current.select();
        }
      } else {
        // console.log('>> app._components.PoemLineInput.useEffect() resetting', { id, visible, value, updatedLine: localValue, ref });
        setActive(false);
        // @ts-ignore
        ref?.current && ref.current.blur();
      }
    } else {
      // console.log('>> app._components.PoemLineInput.useEffect() resetting', { id, activeId, visible, select, value, updatedLine: localValue });
      // @ts-ignore
      ref?.current && ref.current.blur();
      setLocalValue(value || "");
      setActive(false);
    }
  }, [value, id, activeId]);

  return (
    <input
      //@ts-ignore
      ref={ref}
      className="w-full absolute top-0 left-[-0.01rem] px-[0.5rem]"
      onChange={(e: any) => {
        setLocalValue(e.target.value);
        onChange(e.target.value);
      }}
      value={localValue}
    />
  )
}

export default function HaikuPoem({
  user,
  mode,
  haiku,
  popPoem,
  styles,
  altStyles,
  regenerate,
  refresh,
}: {
  user: User,
  mode: string,
  haiku: Haiku,
  popPoem?: boolean,
  styles: any[],
  altStyles?: any[],
  regenerate?: any,
  refresh?: any
}) {
  // console.log('>> app._components.HaikuPoem.render()', { mode, haikuId: haiku?.id, status: haiku.status, popPoem, haiku });
  const isHaikudleMode = mode == "haikudle";
  const isShowcaseMode = mode == "showcase";
  const maxHaikuTheme = 18;
  const dateCode = moment().format("YYYYMMDD");

  const [updatedPoem, setUpdatedPoem] = useState<string[]>([]);
  const [editingPoemLine, setEditingPoemLine] = useState<number | undefined>(undefined);
  const [saving, setSaving] = useState(false);
  const [select, setExpandSelection] = useState(false);
  const [alert] = useAlert((state: any) => [state.plain]);
  const [saveHaiku] = useHaikus((state: any) => [state.save]);
  // console.log('>> app._components.HaikuPage.HaikuPoem.render()', { haiku, updatedPoem, editingPoemLine });

  const haikuTitleAndAuthorTag = [
    `"${capitalize(haiku.theme)}", `,
    `generated by ${isHaikudleMode || isShowcaseMode ? "haikudle.art" : "haiku.desmat.ca"} (${moment(haiku.createdAt).format("YYYY")})`
  ];

  const handleClickHaiku = (e: any) => {
    if (isShowcaseMode) {
      return refresh && refresh(e);
    }

    const haikuToCopy = haiku.poem
      .map((value: string, i: number) => upperCaseFirstLetter(updatedPoem[i] || value))
      .join("\n")
      + `\n—${haikuTitleAndAuthorTag.join("")}\n`;

    // console.log('>> app._components.HaikuPage.handleClickHaiku()', { haikuToCopy });
    navigator.clipboard.writeText(haikuToCopy);

    alert(`Haiku poem copied to clipboard`, { closeDelay: 750 });

    trackEvent("haiku-copied", {
      userId: user.id,
      id: haiku.id,
    });
  }

  const startEdit = (inputIndex: number, select?: boolean) => {
    // console.log('>> app._components.HaikuPoem.startEdit()', { inputIndex, select, updatedPoem });
    setEditingPoemLine(inputIndex);
    setExpandSelection(!!select);
  }

  const cancelEdit = () => {
    // console.log('>> app._components.HaikuPoem.cancelEdit()', { haiku, poem: haiku.poem, updatedLines: updatedPoem });
    setUpdatedPoem([]);
    setEditingPoemLine(undefined);
  }

  const finishEdit = async () => {
    // console.log('>> app._components.HaikuPoem.finishEdit()', { haiku, poem: haiku.poem, updatedLines: updatedPoem });
    setEditingPoemLine(undefined);

    const hasUpdates = (original: string[], updates: string[]): boolean => {
      return original
        .reduce((reduced: boolean, value: string, i: number) => {
          return reduced || typeof (updates[i]) == "string" && updates[i] != value;
        }, false);
    }

    if (!hasUpdates(haiku.poem, updatedPoem)) {
      // no updates to save
      setUpdatedPoem([]);
      return;
    }

    setSaving(true);

    const syllables = haiku.poem
      .map((value: string, i: number) => (updatedPoem[i] || value || "").split(/\s/)
        .map((word: string) => syllable(word))
        .reduce((a: number, v: number) => a + v, 0))
    // console.log('>> app._components.HaikuPoem.finishEdit()', { syllables });

    const updatedOpen = haiku.poem
      .map((value: string, i: number) => {
        if (updatedPoem[i] == "") return "...";
        if (updatedPoem[i] && (updatedPoem[i].includes("...") || updatedPoem[i].includes("…"))) return updatedPoem[i];
        // if ((i == 0 || i == 2) && syllables[i] <= 3) return `${updatedLines[i] || value} ...`;
        // if (i == 1 && syllables[i] <= 5) return `${updatedLines[i] || value} ...`;
        if ((i == 0 || i == 2) && syllables[i] <= 3) return `... ${updatedPoem[i] || value} ...`;
        if (i == 1 && syllables[i] <= 5) return `... ${updatedPoem[i] || value} ...`;
        return updatedPoem[i] || value;
      });

    try {
      const saved = await saveHaiku(user, {
        ...haiku,
        originalPoem: haiku.poem,
        poem: updatedOpen,
      });

      // console.log('>> app._components.HaikuPoem.finishEdit()', { saved });
      haiku.poem = saved.poem;
    } catch (error: any) {
      // console.log('>> app._components.HaikuPoem.finishEdit()', { error });
      // assumption that saveHaiku store showed an error alert
    }

    setUpdatedPoem([]);
    setSaving(false);
  }

  const handlePoemLineKeyDown = (e: any, lineNumber: number) => {
    // console.log(">> app._components.HaikuPoem.handlePoemLineKeyDown", { e, key: e.key, lineNumber });
    if (e.key == "Escape") {
      cancelEdit();
    } else if (e.key == "Enter") {
      if (lineNumber == haiku.poem.length - 1) {
        setEditingPoemLine(undefined);
        finishEdit();
      } else {
        startEdit(lineNumber + 1);
      }
    } else if (e.key == "Tab") {
      if (lineNumber == 0 && e.shiftKey || lineNumber == haiku.poem.length - 1 && !e.shiftKey) {
        e.preventDefault();
        finishEdit();
      } else {
        e.preventDefault();
        startEdit(lineNumber + (e.shiftKey ? -1 : 1), true);
      }
    } else if (e.key == "ArrowUp" && lineNumber > 0) {
      e.preventDefault();
      startEdit(lineNumber - 1, true);
    } else if (e.key == "ArrowDown" && lineNumber < haiku.poem.length - 1) {
      e.preventDefault();
      startEdit(lineNumber + 1, true);
    } else if (["ArrowUp", "ArrowDown"].includes(e.key)) {
      e.preventDefault();
    }
  };

  const handleInputChange = (value: string, lineNumber: number) => {
    // console.log('>> app._components.HaikuPoem.handleInputChange()', { value, lineNumber });
    const update = [...updatedPoem];
    update[lineNumber] = upperCaseFirstLetter(value);
    setUpdatedPoem(update);
  };

  const handleKeyDown = async (e: any) => {
    // console.log(">> app._component.SidePanel.handleKeyDown", { panelOpened, panelAnimating });
    if (e.key == "Tab" && typeof (editingPoemLine) != "number") {
      e.preventDefault();
      startEdit(0, true);
    }
  };

  useEffect(() => {
    // console.log(">> app._component.SidePanel.useEffect", { mode, haiku });
    document.body.addEventListener('keydown', handleKeyDown);

    return () => {
      document.body.removeEventListener('keydown', handleKeyDown)
    }
  }, []);

  return (
    <div className="relative">
      <div
        className={`_bg-pink-200 fixed top-0 left-0 w-[100vw] h-[100vh]${saving ? " opacity-50" : ""}`}
        onClick={() => typeof (editingPoemLine) == "number" && finishEdit()}
      />

      <PopOnClick color={haiku.bgColor} force={popPoem} disabled={!isShowcaseMode}>
        <div className={saving ? "animate-pulse" : ""}>
          <div
            className="_bg-purple-200 flex flex-col transition-all"
            onClick={(e: any) => {
              e.preventDefault();
              isShowcaseMode && handleClickHaiku(e);
            }}
            title={isShowcaseMode ? "Refresh" : "Click to edit"}
            style={{
              cursor: isShowcaseMode ? "pointer" : ""
            }}
          >
            {haiku.poem.map((poemLine: string, i: number) => (
              <StyledLayers key={i} styles={styles}>
                <div
                  className="relative m-[0rem] transition-all"
                  onKeyDown={(e: any) => handlePoemLineKeyDown(e, i)}
                  onMouseDown={(e: any) => startEdit(i, false)}
                >
                  {/* set the width while editing */}
                  <div
                    className="_bg-pink-200 invisible px-[0.5rem] h-[2.2rem] sm:h-[2.6rem] md:h-[3.2rem]"
                  >
                    {/* keep at minimum original width to avoid wierd alignment issues */}
                    <div className="bg-orange-200 h-0 invisible">
                      {saving ? typeof (updatedPoem[i]) == "string" ? updatedPoem[i] : poemLine : poemLine}
                    </div>
                    {/* and stretch if updates are longer */}
                    <div className="bg-orange-400 h-0 invisible">
                      {saving ? typeof (updatedPoem[i]) == "string" ? updatedPoem[i] : poemLine : updatedPoem[i]}
                    </div>
                  </div>

                  {/* input field used in both view and edit modes */}
                  {/* note: https://stackoverflow.com/questions/28269669/css-pseudo-elements-in-react */}
                  <style
                    dangerouslySetInnerHTML={{
                      __html: `
                        .poem-line-input input {
                          background: none;
                          _background: pink; /* for debugging */
                        }
                        .poem-line-input input:focus {
                          outline: 2px solid ${haiku?.bgColor || ""}66;
                          background-color: ${haiku?.bgColor || "white"}66;
                          border-radius: 5px;
                          caret-color: ${haiku?.color || "black"};
                        }
                        .poem-line-input input::selection { 
                          background: ${haiku.color || "black"}66 
                        }`
                    }}
                  >
                  </style>
                  <div className="poem-line-input">
                    <ControlledInput
                      id={i}
                      activeId={editingPoemLine}
                      value={saving ? typeof (updatedPoem[i]) == "string" ? updatedPoem[i] : poemLine : poemLine}
                      visible={editingPoemLine == i}
                      select={select}
                      onChange={(value: string) => handleInputChange(value, i)}
                    />
                  </div>
                </div>
              </StyledLayers>
            ))}
          </div>
          <div
            className="relative md:text-[14pt] sm:text-[10pt] text-[8pt] md:mt-[0.0rem] sm:mt-[0.1rem] mt-[-0.1rem] pl-[0.7rem]"
            style={{
              height: mode == "haikudle"
                ? ""
                : haiku.theme?.length > maxHaikuTheme
                  ? "2.6rem"
                  : "1.3rem"
            }}
          >
            <div className="absolute w-max flex flex-row">
              <div
                className="transition-all"
                onClick={(e: any) => isShowcaseMode && handleClickHaiku(e)}
                title={isShowcaseMode ? "Refresh" : ""}
                style={{
                  cursor: isShowcaseMode ? "pointer" : ""
                }}
              >
                <StyledLayers styles={styles}>
                  <span
                    dangerouslySetInnerHTML={{ __html: `—${haikuTitleAndAuthorTag.join(haiku.theme?.length > maxHaikuTheme ? "<br/>&nbsp;" : "")}` }}
                  >
                  </span>
                </StyledLayers>
              </div>

              {regenerate && !isShowcaseMode && (user?.isAdmin || haiku.createdBy == user?.id) &&
                <div
                  className="flex flex-row gap-2 mt-auto md:pt-[0rem] sm:pt-[0.0rem] md:pb-[0.4rem] sm:pb-[0.3rem] pb-[0.2rem] md:pl-[0.9rem] sm:pl-[0.7rem] pl-[0.5rem]"
                >
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Copy to clipboard"
                    onClick={(e: any) => {
                      e.preventDefault();
                      handleClickHaiku(e);
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaCopy className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  <Link
                    href="#"
                    className="cursor-pointer"
                    title="Edit this haiku"
                    onClick={(e: any) => {
                      e.preventDefault();
                      startEdit(0, true);
                    }}
                  >
                    <StyledLayers styles={altStyles || []}>
                      <FaEdit className="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                    </StyledLayers>
                  </Link>
                  {!user?.isAdmin && (user.usage[dateCode]?.haikusRegenerated || 0) >= USAGE_LIMIT.DAILY_REGENERATE_HAIKU &&
                    <span
                      className="opacity-40"
                      title="Exceeded daily limit: try again later"
                    >
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6" />
                      </StyledLayers>
                    </span>
                  }
                  {(user?.isAdmin || (user.usage[dateCode]?.haikusRegenerated || 0) < USAGE_LIMIT.DAILY_REGENERATE_HAIKU) &&
                    <span title="Regenerate this haiku with the same theme">
                      <StyledLayers styles={altStyles || []}>
                        <GenerateIcon
                          onClick={() => regenerate && regenerate()}
                          sizeOverwrite="h-3 w-3 sm:h-4 sm:w-4 md:h-6 md:w-6"
                        />
                      </StyledLayers>
                    </span>
                  }
                </div>
              }
            </div>
          </div>
        </div>
      </PopOnClick>
    </div>
  )
}
