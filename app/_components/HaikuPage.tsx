'use client'

import moment from "moment";
import { useEffect, useState } from "react";
import { DragDropContext, Draggable, Droppable } from "@hello-pangea/dnd";
import useHaikudle from '@/app/_hooks/haikudle';
import * as font from "@/app/font";
import { Haiku } from "@/types/Haiku";
import { capitalize } from "@/utils/format";
import { StyledLayers } from "./StyledLayers";

function HaikuPoem({
  mode,
  haiku,
  styles,
  selectedWord,
  setSelectedWord,
}: {
  mode: string,
  haiku: Haiku,
  styles: any[],
  selectedWord: any,
  setSelectedWord: any,
}) {
  console.log('>> app._components.HaikuPage.HaikuPoem.render()', { mode, haiku });

  const [
    inProgress,
    solved,
    swap,
    haikudleId,
  ] = useHaikudle((state: any) => [
    state.inProgress,
    state.solved,
    state.swap,
    state.haikudleId,
  ]);

  const isHaikudleMode = mode == "haikudle";
  const isLyricleMode = mode == "lyricle";
  const isPuzzleMode = isHaikudleMode || isLyricleMode;
  const poem = isPuzzleMode ? inProgress : haiku.poem.map((line: string) => line.split(/\s+/).map((w: string) => { return { word: w } }));

  // console.log('>> app._components.HaikuPage.HaikuPoem.render()', { poem });

  const upperCaseFirstLetter = (s: string) => {
    if (!s || s.length == 0) return "";
    return s.substring(0, 1).toUpperCase() + s.substring(1);
  }

  const [pop, setPop] = useState(false);

  // console.log('>> app._components.HaikuPage.render()', { inProgress });

  const doPop = () => {
    setPop(true);
    setTimeout(() => setPop(false), 100);
  }

  useEffect(() => {
    if (solved) {
      doPop();
    }
  }, [solved]);

  const handleClickWord = (word: any, lineNumber: number, wordNumber: number) => {
    // console.log('>> app._components.HaikuPage.handleClickWord()', { word, lineNumber, wordNumber });

    if (word.id == selectedWord?.word?.id) {
      setSelectedWord(undefined);
    } else if (selectedWord) {
      swap(
        haikudleId,
        selectedWord.word,
        selectedWord.lineNumber,
        selectedWord.wordNumber,
        lineNumber,
        wordNumber,
      );
      setSelectedWord(undefined);
    } else {
      setSelectedWord({
        word,
        lineNumber,
        wordNumber,
      });
    }
  }

  const haikuTitleAndAuthorTag = `"${capitalize(haiku.theme)}", generated by ${isHaikudleMode ? "haikudle.art" : "haiku.desmat.ca"} (${moment(haiku.createdAt).format("YYYY")})`;

  const handleClickHaiku = () => {
    const haikuToCopy = poem.map((s: string, i: number) => {
      return upperCaseFirstLetter(
        poem[i]
          .map((w: any) => w.word)
          .join(" "));
    })
      .join("\n")
      + `\n—${haikuTitleAndAuthorTag}\n`;

    doPop();
    // console.log('>> app._components.HaikuPage.handleClickHaiku()', { haikuToCopy });
    navigator.clipboard.writeText(haikuToCopy);
  }

  if (solved || !isPuzzleMode) {
    return (
      <div
        className="_bg-purple-200 flex flex-col cursor-copy transition-all"
        onClick={handleClickHaiku}
        title="Copy to clipboard"
        style={{
          filter: `${pop ? `drop-shadow(0px 0px 32px ${haiku?.bgColor})` : ""}`,
        }}
      >
        {poem.map((s: string, i: number) => (
          <StyledLayers key={i} styles={styles}>
            <div className="m-[0rem] transition-all">
              {upperCaseFirstLetter(poem[i].map((w: any) => w.word).join(" "))}
            </div>
          </StyledLayers>
        ))}
        {(solved || !isPuzzleMode) &&
          <div className="relative md:text-[20pt] sm:text-[16pt] text-[12pt]">
            <div className="absolute w-max">
              <StyledLayers styles={styles}>
              {`—${haikuTitleAndAuthorTag}`}
              </StyledLayers>
            </div>
          </div>
        }
      </div>
    )
  }

  return (
    <>
      {poem.map((s: string, i: number) => {
        return (
          <Droppable
            key={`${i}`}
            droppableId={`${i}`}
            direction="horizontal"
          >
            {(provided, snapshot) => {
              return (
                <div
                  {...provided.droppableProps}
                  ref={provided.innerRef}
                  className={`_bg-purple-200 flex flex-row items-center justify-start my-0 px-5 sm:min-h-[2.8rem] md:min-h-[3.4rem] min-h-[2.4rem] h-fit w-full select-none`}
                >
                  {poem[i].map((w: any, j: number) => {
                    return (
                      <Draggable
                        key={`word-${i}-${j}`}
                        draggableId={`word-${i}-${j}`}
                        index={j}
                        isDragDisabled={!isPuzzleMode || w?.correct}
                        shouldRespectForcePress={true}
                        // timeForLongPress={0}
                      >
                        {(provided, snapshot) => {
                          return (
                            <span
                              ref={provided.innerRef}
                              {...provided.draggableProps}
                              {...provided.dragHandleProps}
                              onMouseDown={() => isPuzzleMode && !w?.correct && handleClickWord(w, i, j)}
                            >
                              <StyledLayers key={i} styles={!isPuzzleMode || solved || w?.correct ? styles : [styles[0]]}>
                                <div
                                  className={`px-1 ${!isPuzzleMode || solved || w?.correct ? "" : "m-1"} transition-all ${!solved && !w?.correct && "draggable-notsure-why-cant-inline"}`}
                                  style={{
                                    backgroundColor: (!isPuzzleMode || solved || w?.correct)
                                      ? undefined
                                      : haiku?.bgColor || "lightgrey",
                                    filter: (!isPuzzleMode || solved || w?.correct)
                                      ? undefined
                                      : snapshot.isDragging
                                        ? `drop-shadow(0px 1px 3px rgb(0 0 0 / 0.9))`
                                        : selectedWord?.word?.id == w?.id
                                          ? `drop-shadow(0px 1px 2px rgb(0 0 0 / 0.9))`
                                          : selectedWord
                                            ? `drop-shadow(0px 1px 1px rgb(0 0 0 / 0.5))`
                                            : `drop-shadow(0px 1px 1px rgb(0 0 0 / 0.2))`,
                                  }}
                                >
                                  {j == 0 && w?.correct &&
                                    upperCaseFirstLetter(w?.word)
                                  }
                                  {!(j == 0 && w?.correct) &&
                                    w?.word
                                  }
                                </div>
                              </StyledLayers>
                            </span>
                          )
                        }}
                      </Draggable>
                    )
                  })}
                  {provided.placeholder}
                </div>
              )
            }}
          </Droppable>
        )
      })}
    </>
  )
}

export default function HaikuPage({ mode, haiku, styles }: { mode: string, haiku?: Haiku, styles: any[] }) {
  // console.log('>> app._components.HaikuPage.render()', { mode, haiku, id: haiku.id });

  const isHaikudleMode = mode == "haikudle";
  const isLyricleMode = mode == "lyricle";
  const isPuzzleMode = isHaikudleMode || isLyricleMode;

  const [
    loaded,
    load,
    inProgress,
    init,
    move,
    _haiku,
    haikudleId,
    haikudleSolved,
  ] = useHaikudle((state: any) => [
    state.loaded,
    state.load,
    state.inProgress,
    state.init,
    state.move,
    isPuzzleMode ? state.haiku : haiku,
    state.haikudleId,
    state.solved,
  ]);

  // TODO move to hook store
  const [selectedWord, setSelectedWord] = useState<any>();
  // console.log('>> app._components.HaikuPage.render()', { inProgress });

  const handleDragStart = (result: any) => {
    // console.log('>> app._components.HaikuPage.handleDragStart()', { result });

    setSelectedWord({
      word: inProgress.flat().find((w: any) => w?.id == result.draggableId),
      lineNumber: Number(result.source.droppableId),
      wordNumber: result.source.index,
    });
  }

  const handleDragEnd = (result: any) => {
    // console.log('>> app._components.HaikuPage.handleDragEnd()', { result });

    setSelectedWord(undefined);

    if (result.destination && !(result.source.droppableId == result.destination.droppableId && result.source.index == result.destination.index)) {
      move(
        haikudleId,
        Number(result.source.droppableId),
        result.source.index,
        Number(result.destination.droppableId),
        result.destination.index
      );
    }
  }

  const blurCurve = ["lyricle", "social-img-lyricle"].includes(mode)
    ? [0, 1, 2.5, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
    : [0, 1, 1.5, 2, 2.5, 3, 4, 5, 6, 7, 8, 9, 10];
  const saturateCurve = ["lyricle", "social-img-lyricle"].includes(mode)
    ? [0.8, 1, 1.2, 1.3, 1.35, 1.45, 1.5, 1.55, 1.6]
    : [1];
  const numWords = inProgress.flat().length;
  let numCorrectWords = inProgress.flat().filter((word: any) => word.correct).length
  // if (numCorrectWords > 0) numCorrectWords = numCorrectWords + 1; // make the last transition more impactful
  let blurValue = mode == "social-img-lyricle"
    ? blurCurve[blurCurve.length - 1]
    : blurCurve[numWords - numCorrectWords];
  let saturateValue = mode == "social-img-lyricle"
    ? saturateCurve[saturateCurve.length - 1]
    : saturateCurve[numWords - numCorrectWords];

  if (typeof (blurValue) != "number") {
    blurValue = blurCurve[blurCurve.length - 1];
  }
  if (typeof (saturateValue) != "number") {
    saturateValue = saturateCurve[saturateCurve.length - 1];
  }
  // console.log('>> app._components.HaikuPage.render()', { numWords, numCorrectWords, blurValue });

  return (
    <div>
      <DragDropContext
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
      >
        <div
          className="bar fixed top-0 left-0 _bg-pink-200 min-w-[100vw] min-h-[100vh] z-0 opacity-100"
          style={{
            backgroundImage: `url("${_haiku?.bgImage}")`,
            backgroundPosition: "center",
            backgroundSize: "cover",
            filter: `brightness(1.2) blur(${blurValue}px) saturate(${saturateValue}) `,
            transition: "filter 0.5s ease-out",
          }}
        />

        <div className={`${font.architects_daughter.className} _bg-yellow-200 md:text-[26pt] sm:text-[22pt] text-[16pt] fixed top-0 left-0 right-0 bottom-0 m-auto w-fit h-fit z-10 transition-all `}>
          {!["social-img", "social-img-lyricle"].includes(mode) &&
            <HaikuPoem mode={mode} haiku={_haiku} styles={styles} selectedWord={selectedWord} setSelectedWord={setSelectedWord} />
          }
        </div>
      </DragDropContext>
    </div >
  )
}
